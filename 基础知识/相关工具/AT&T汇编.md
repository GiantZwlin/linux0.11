

## AT&T 汇编(x86_64)

### 数据格式

| C声明  | Intel数据类型     | 汇编代码后缀 | 大小（字节） |
| ------ | ----------------- | ------------ | ------------ |
| char   | 字节              | b            | 1            |
| short  | 字                | w            | 2            |
| int    | 双字              | l            | 4            |
| long   | 四字 (quad words) | q            | 8            |
| char * | 四字              | q            | 8            |
| float  | 单精度            | s            | 4            |
| double | 双精度            | l            | 8            |

**注意**：汇编代码也使用后缀`l`来表示四字节整数和8字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。

### 访问信息

寄存器信息

![x86_64寄存器.png](./x86_64寄存器.png)



寄存器仍然向前兼容，即仍有例如`ax，ah，al`的寄存器访问方式。

### 操作数指示符

大多数指令都有一个或多个操作数。指示执行一个操作中要使用的源数据值，以及放置结果的目的位置。

#### 操作数类型

+ 立即数(immediate)
+ 寄存器(register)
+ 内存引用

#### 寻址模式

![操作数格式](./操作数格式.png)

> $Imm 表示立即数
>
> M[Imm]表示直接寻址
>
> R[ra] 表示寄存器直接寻址
>
> M[R[ra]] 表示寄存器间接寻址
>
> 剩下的形式即为各种**变址寻址**的方式

### 数据传送指令

MOV类指令

**传送指令的两个操作数不能都指向内存位置**,将一个值从一个内存位置复制到另一个内存位置需要两条指令，即先复制到寄存器，再从寄存器复制到内存。

#### 简单的数据传送指令

![简单的数据传送指令](./简单的数据传送指令.png)

#### 零扩展数据传送指令

![零扩展数据传送指令](./零扩展数据传送指令.png)

#### 符号扩展数据传送指令

![符号扩展数据传送指令](./符号扩展数据传送指令.png)

`movl`指令指令以寄存器为目的时，会把该寄存器的高位四字节设置为0，因此所有源类型都有对应的符号扩展，二只有较小的两种源类型有零扩展传送

`ctlq`指令没有操作数，它总是以寄存器`%eax`作为源，`%rax`作为符号扩展结果的目的。

#### 压入和弹出栈数据

栈在处理过程调用中起到至关作用的作用。`%rsp`表示栈顶指针寄存器

![栈操作](./栈操作.png)

如图所示，栈向下生长，既栈顶元素的地址是所有栈中元素地址最低的，根据惯例，内存的示意图低地址在下，高地址在上。

![栈内存示意](./栈内存示意.png)

**入栈**:首先栈顶地址减8(即操作字长)，然后将值写到新的栈顶地址。

**出栈**:先将值写出，在将栈顶地址加8(操作数字长)

### 算数和逻辑操作

常见的算数和逻辑操作

![常见的算数逻辑操作](./算逻操作.png)

#### 加载有效地址

`加载有效地址`(load effective address)指令leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器，但实际上他根本就没有引用内存。他的第一个操作数看上去是一个内存引用，但实际上，该指令并不是从指定的位置读取数据，而是**将有效地址写入到目的操作数**。